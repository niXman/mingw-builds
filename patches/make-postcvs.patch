diff --git a/getopt.c b/getopt.c
index e992da5..a328100 100644
--- a/getopt.c
+++ b/getopt.c
@@ -436,6 +436,9 @@ _getopt_initialize (int argc, char *const *argv, const char *optstring)
     }
   else
     nonoption_flags_len = 0;
+#else
+  (void)argc;
+  (void)argv;
 #endif
 
   return optstring;
@@ -678,7 +681,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		optarg = nameend + 1;
 	      else
 		{
-		  if (opterr)
+		  if (opterr) {
 		   if (argv[optind - 1][1] == '-')
 		    /* --option */
 		    fprintf (stderr,
@@ -689,7 +692,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		    fprintf (stderr,
 		     _("%s: option `%c%s' doesn't allow an argument\n"),
 		     argv[0], argv[optind - 1][0], pfound->name);
-
+		  }
 		  nextchar += strlen (nextchar);
 
 		  optopt = pfound->val;
--- make_cvs/w32/subproc/w32err.c	2010-07-13 05:20:43 +0400
+++ make/w32/subproc/w32err.c	2012-06-25 20:53:20 +0400
@@ -1,6 +1,5 @@
 /* Error handling for Windows
-Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+Copyright (C) 1996-2012 Free Software Foundation, Inc.
 This file is part of GNU Make.
 
 GNU Make is free software; you can redistribute it and/or modify it under the
@@ -15,7 +14,9 @@
 You should have received a copy of the GNU General Public License along with
 this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
+#include <stdlib.h>
 #include <windows.h>
+#include "make.h"
 #include "w32err.h"
 
 /*
@@ -26,14 +27,24 @@
  * Notes/Dependencies:  I got this from
  *      comp.os.ms-windows.programmer.win32
  */
-char *
+const char *
 map_windows32_error_to_string (DWORD ercode) {
-/* __declspec (thread) necessary if you will use multiple threads on MSVC */
-#ifdef _MSC_VER
-__declspec (thread) static char szMessageBuffer[128];
-#else
-static char szMessageBuffer[128];
-#endif
+/*
+ * We used to have an MSVC-specific '__declspec (thread)' qualifier
+ * here, with the following comment:
+ *
+ * __declspec (thread) necessary if you will use multiple threads on MSVC
+ *
+ * However, Make was never multithreaded on Windows (except when
+ * Ctrl-C is hit, in which case the main thread is stopped
+ * immediately, so it doesn't matter in this context).  The functions
+ * on sub_proc.c that started and stopped additional threads were
+ * never used, and are now #ifdef'ed away.  Until we need more than
+ * one thread, we have no problems with the following buffer being
+ * static.  (If and when we do need it to be in thread-local storage,
+ * the corresponding GCC qualifier is '__thread'.)
+ */
+    static char szMessageBuffer[128];
 	/* Fill message buffer with a default message in
 	 * case FormatMessage fails
 	 */
@@ -43,6 +54,7 @@
 	 *  Special code for winsock error handling.
 	 */
 	if (ercode > WSABASEERR) {
+#if 0
 		HMODULE hModule = GetModuleHandle("wsock32");
 		if (hModule != NULL) {
 			FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
@@ -54,6 +66,9 @@
 				NULL);
 			FreeLibrary(hModule);
 		}
+#else
+		fatal(NILF, szMessageBuffer);
+#endif
 	} else {
 		/*
 		 *  Default system message handling
--- make_cvs/w32/subproc/sub_proc.c	2011-11-16 01:12:54 +0400
+++ make/w32/subproc/sub_proc.c	2012-06-25 20:53:20 +0400
@@ -1,6 +1,5 @@
 /* Process handling for Windows.
-Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+Copyright (C) 1996-2012 Free Software Foundation, Inc.
 This file is part of GNU Make.
 
 GNU Make is free software; you can redistribute it and/or modify it under the
@@ -462,17 +461,19 @@
 	sub_process *pproc;
 
 	pproc = malloc(sizeof(*pproc));
-	memset(pproc, 0, sizeof(*pproc));
+	if (pproc) {
+		memset(pproc, 0, sizeof(*pproc));
 
-	/*
-	 * Just pass the provided file handles to the 'child side' of the
-	 * pipe, bypassing pipes altogether.
-	 */
-	pproc->sv_stdin[1]  = (intptr_t) stdinh;
-	pproc->sv_stdout[1] = (intptr_t) stdouth;
-	pproc->sv_stderr[1] = (intptr_t) stderrh;
+		/*
+		 * Just pass the provided file handles to the 'child
+		 * side' of the pipe, bypassing pipes altogether.
+		 */
+		pproc->sv_stdin[1]  = (intptr_t) stdinh;
+		pproc->sv_stdout[1] = (intptr_t) stdouth;
+		pproc->sv_stderr[1] = (intptr_t) stderrh;
 
-	pproc->last_err = pproc->lerrno = 0;
+		pproc->last_err = pproc->lerrno = 0;
+	}
 
 	return((HANDLE)pproc);
 }
@@ -711,9 +712,12 @@
 	CloseHandle(procInfo.hThread);
 
 	/* Close the halves of the pipes we don't need */
-        CloseHandle((HANDLE)pproc->sv_stdin[1]);
-        CloseHandle((HANDLE)pproc->sv_stdout[1]);
-        CloseHandle((HANDLE)pproc->sv_stderr[1]);
+	if ((HANDLE)pproc->sv_stdin[1] != INVALID_HANDLE_VALUE)
+	  CloseHandle((HANDLE)pproc->sv_stdin[1]);
+	if ((HANDLE)pproc->sv_stdout[1] != INVALID_HANDLE_VALUE)
+	  CloseHandle((HANDLE)pproc->sv_stdout[1]);
+	if ((HANDLE)pproc->sv_stderr[1] != INVALID_HANDLE_VALUE)
+	  CloseHandle((HANDLE)pproc->sv_stderr[1]);
         pproc->sv_stdin[1] = 0;
         pproc->sv_stdout[1] = 0;
         pproc->sv_stderr[1] = 0;
@@ -726,6 +730,7 @@
 
 
 
+#if 0	/* unused */
 static DWORD
 proc_stdin_thread(sub_process *pproc)
 {
@@ -970,6 +975,7 @@
 		return(0);
 
 }
+#endif	/* unused */
 
 /*
  * Purpose: collects output from child process and returns results
@@ -1064,11 +1070,14 @@
 
 	if (pproc->using_pipes) {
 		for (i= 0; i <= 1; i++) {
-			if ((HANDLE)pproc->sv_stdin[i])
+			if ((HANDLE)pproc->sv_stdin[i]
+			    && (HANDLE)pproc->sv_stdin[i] != INVALID_HANDLE_VALUE)
 				CloseHandle((HANDLE)pproc->sv_stdin[i]);
-			if ((HANDLE)pproc->sv_stdout[i])
+			if ((HANDLE)pproc->sv_stdout[i]
+			    && (HANDLE)pproc->sv_stdout[i] != INVALID_HANDLE_VALUE)
 				CloseHandle((HANDLE)pproc->sv_stdout[i]);
-			if ((HANDLE)pproc->sv_stderr[i])
+			if ((HANDLE)pproc->sv_stderr[i]
+			    && (HANDLE)pproc->sv_stderr[i] != INVALID_HANDLE_VALUE)
 				CloseHandle((HANDLE)pproc->sv_stderr[i]);
 		}
 	}
@@ -1333,50 +1342,100 @@
 	char **argv,
 	char **envp)
 {
-  HANDLE hIn;
-  HANDLE hOut;
-  HANDLE hErr;
-  HANDLE hProcess;
+  HANDLE hIn = INVALID_HANDLE_VALUE;
+  HANDLE hOut = INVALID_HANDLE_VALUE;
+  HANDLE hErr = INVALID_HANDLE_VALUE;
+  HANDLE hProcess, tmpIn, tmpOut, tmpErr;
+  DWORD e;
 
   if (proc_index >= MAXIMUM_WAIT_OBJECTS) {
 	DB (DB_JOBS, ("process_easy: All process slots used up\n"));
 	return INVALID_HANDLE_VALUE;
   }
+  /* Standard handles returned by GetStdHandle can be NULL or
+     INVALID_HANDLE_VALUE if the parent process closed them.  If that
+     happens, we open the null device and pass its handle to
+     CreateProcess as the corresponding handle to inherit.  */
+  tmpIn = GetStdHandle(STD_INPUT_HANDLE);
   if (DuplicateHandle(GetCurrentProcess(),
-                      GetStdHandle(STD_INPUT_HANDLE),
-                      GetCurrentProcess(),
-                      &hIn,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    fprintf(stderr,
-            "process_easy: DuplicateHandle(In) failed (e=%ld)\n",
-            GetLastError());
-    return INVALID_HANDLE_VALUE;
+		      tmpIn,
+		      GetCurrentProcess(),
+		      &hIn,
+		      0,
+		      TRUE,
+		      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpIn = CreateFile("NUL", GENERIC_READ,
+			 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+			 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpIn != INVALID_HANDLE_VALUE
+	  && DuplicateHandle(GetCurrentProcess(),
+			     tmpIn,
+			     GetCurrentProcess(),
+			     &hIn,
+			     0,
+			     TRUE,
+			     DUPLICATE_SAME_ACCESS) == FALSE)
+	CloseHandle(tmpIn);
+    }
+    if (hIn == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(In) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
   }
+  tmpOut = GetStdHandle (STD_OUTPUT_HANDLE);
   if (DuplicateHandle(GetCurrentProcess(),
-                      GetStdHandle(STD_OUTPUT_HANDLE),
-                      GetCurrentProcess(),
-                      &hOut,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    fprintf(stderr,
-           "process_easy: DuplicateHandle(Out) failed (e=%ld)\n",
-           GetLastError());
-    return INVALID_HANDLE_VALUE;
+		      tmpOut,
+		      GetCurrentProcess(),
+		      &hOut,
+		      0,
+		      TRUE,
+		      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpOut = CreateFile("NUL", GENERIC_WRITE,
+			  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpOut != INVALID_HANDLE_VALUE
+	  && DuplicateHandle(GetCurrentProcess(),
+			     tmpOut,
+			     GetCurrentProcess(),
+			     &hOut,
+			     0,
+			     TRUE,
+			     DUPLICATE_SAME_ACCESS) == FALSE)
+	CloseHandle(tmpOut);
+    }
+    if (hOut == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(Out) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
   }
+  tmpErr = GetStdHandle(STD_ERROR_HANDLE);
   if (DuplicateHandle(GetCurrentProcess(),
-                      GetStdHandle(STD_ERROR_HANDLE),
-                      GetCurrentProcess(),
-                      &hErr,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    fprintf(stderr,
-            "process_easy: DuplicateHandle(Err) failed (e=%ld)\n",
-            GetLastError());
-    return INVALID_HANDLE_VALUE;
+		      tmpErr,
+		      GetCurrentProcess(),
+		      &hErr,
+		      0,
+		      TRUE,
+		      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpErr = CreateFile("NUL", GENERIC_WRITE,
+			  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpErr != INVALID_HANDLE_VALUE
+	  && DuplicateHandle(GetCurrentProcess(),
+			     tmpErr,
+			     GetCurrentProcess(),
+			     &hErr,
+			     0,
+			     TRUE,
+			     DUPLICATE_SAME_ACCESS) == FALSE)
+	CloseHandle(tmpErr);
+    }
+    if (hErr == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(Err) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
   }
 
   hProcess = process_init_fd(hIn, hOut, hErr);
@@ -1389,9 +1448,12 @@
     ((sub_process*) hProcess)->exit_code = process_last_err(hProcess);
 
     /* close up unused handles */
-    CloseHandle(hIn);
-    CloseHandle(hOut);
-    CloseHandle(hErr);
+    if (hIn != INVALID_HANDLE_VALUE)
+      CloseHandle(hIn);
+    if (hOut != INVALID_HANDLE_VALUE)
+      CloseHandle(hOut);
+    if (hErr != INVALID_HANDLE_VALUE)
+      CloseHandle(hErr);
   }
 
   process_register(hProcess);
--- make_cvs/w32/include/w32err.h	2010-07-13 05:20:43 +0400
+++ make/w32/include/w32err.h	2012-06-25 20:53:20 +0400
@@ -1,6 +1,5 @@
 /* Definitions for Windows error handling.
-Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+Copyright (C) 1996-2012 Free Software Foundation, Inc.
 This file is part of GNU Make.
 
 GNU Make is free software; you can redistribute it and/or modify it under the
@@ -22,6 +21,6 @@
 #define EXTERN_DECL(entry, args) entry args
 #endif
 
-EXTERN_DECL(char * map_windows32_error_to_string, (DWORD error));
+EXTERN_DECL(const char * map_windows32_error_to_string, (DWORD error));
 
 #endif /* !_W32ERR_H */
--- make_cvs/make.h	2011-11-14 06:26:00 +0400
+++ make/make.h	2012-06-25 20:53:18 +0400
@@ -315,11 +316,15 @@
 #define N_(msgid)           gettext_noop (msgid)
 #define S_(msg1,msg2,num)   ngettext (msg1,msg2,num)
 
-/* Handle other OSs.  */
-#ifndef PATH_SEPARATOR_CHAR
-# if defined(HAVE_DOS_PATHS)
-#  define PATH_SEPARATOR_CHAR ';'
-# elif defined(VMS)
+/* Handle other OSs.
+   To overcome an issue parsing paths in a DOS/Windows environment when
+   built in a unix based environment, override the PATH_SEPARATOR_CHAR
+   definition unless being built for Cygwin. */
+#if defined(HAVE_DOS_PATHS) && !defined(__CYGWIN__)
+# undef PATH_SEPARATOR_CHAR
+# define PATH_SEPARATOR_CHAR ';'
+#elif !defined(PATH_SEPARATOR_CHAR)
+# if defined (VMS)
 #  define PATH_SEPARATOR_CHAR ','
 # else
 #  define PATH_SEPARATOR_CHAR ':'
--- make_cvs/main.c	2011-11-16 01:12:54 +0400
+++ make/main.c	2012-06-25 20:53:17 +0400
@@ -1789,7 +1792,6 @@
   if (job_slots > 1)
     {
       char *cp;
-      char c = '+';
 
 #ifdef WINDOWS32
       /* sub_proc.c cannot wait for more than MAXIMUM_WAIT_OBJECTS objects
@@ -1809,6 +1811,8 @@
                  err, map_windows32_error_to_string(err));
         }
 #else
+      char c = '+';
+
       if (pipe (job_fds) < 0 || (job_rfd = dup (job_fds[0])) < 0)
 	pfatal_with_name (_("creating jobs pipe"));
 #endif
@@ -2362,7 +2365,7 @@
   }
 
   /* NOTREACHED */
-  return 0;
+  exit(0);
 }
 
 /* Parsing of arguments, decoding of switches.  */
--- make_cvs/expand.c	2011-08-29 20:20:19 +0400
+++ make/expand.c	2012-06-25 20:53:17 +0400
@@ -497,6 +495,8 @@
 {
   const struct variable *v;
   char *buf = 0;
+  /* If this set is local and the next is not a parent, then next is local.  */
+  int nextlocal = local && set->next_is_parent == 0;
 
   /* If there's nothing left to check, return the empty buffer.  */
   if (!set)
@@ -507,12 +507,12 @@
 
   /* If there isn't one, or this one is private, try the set above us.  */
   if (!v || (!local && v->private_var))
-    return variable_append (name, length, set->next, 0);
+    return variable_append (name, length, set->next, nextlocal);
 
   /* If this variable type is append, first get any upper values.
      If not, initialize the buffer.  */
   if (v->append)
-    buf = variable_append (name, length, set->next, 0);
+    buf = variable_append (name, length, set->next, nextlocal);
   else
     buf = initialize_variable_output ();
 
--- make_cvs/config/dospaths.m4	2010-07-13 05:20:43 +0400
+++ make/config/dospaths.m4	2012-06-25 20:53:18 +0400
@@ -1,8 +1,7 @@
 # Test if the system uses DOS-style pathnames (drive specs and backslashes)
 # By Paul Smith <psmith@gnu.org>.  Based on dos.m4 by Jim Meyering.
 #
-# Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+# Copyright (C) 1993-2012 Free Software Foundation, Inc.
 # This file is part of GNU Make.
 #
 # GNU Make is free software; you can redistribute it and/or modify it under
@@ -18,21 +17,17 @@
 # You should have received a copy of the GNU General Public License along with
 # this program.  If not, see <http://www.gnu.org/licenses/>.
 
-AC_DEFUN([pds_AC_DOS_PATHS],
-  [
-    AC_CACHE_CHECK([whether system uses MSDOS-style paths], [ac_cv_dos_paths],
-      [
-        AC_COMPILE_IFELSE([
+AC_DEFUN([pds_AC_DOS_PATHS], [
+  AC_CACHE_CHECK([whether system uses MSDOS-style paths], [ac_cv_dos_paths], [
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #if !defined _WIN32 && !defined __WIN32__ && !defined __MSDOS__ && !defined __EMX__ && !defined __MSYS__ && !defined __CYGWIN__
 neither MSDOS nor Windows nor OS2
 #endif
-],
+]])],
         [ac_cv_dos_paths=yes],
-        [ac_cv_dos_paths=no])
-      ])
+        [ac_cv_dos_paths=no])])
 
-    if test x"$ac_cv_dos_paths" = xyes; then
-      AC_DEFINE_UNQUOTED([HAVE_DOS_PATHS], 1,
-                         [Define if the system uses DOS-style pathnames.])
-    fi
-  ])
+  AS_IF([test x"$ac_cv_dos_paths" = xyes],
+  [ AC_DEFINE_UNQUOTED([HAVE_DOS_PATHS], 1,
+                       [Define if the system uses DOS-style pathnames.])])
+])
--- make_cvs/config.h.W32.template	2011-11-16 01:12:53 +0400
+++ make/config.h.W32.template	2012-06-25 21:42:22 +0400
@@ -40,7 +40,7 @@
 /* #undef C_ALLOCA */
 
 /* Define to 1 if using `getloadavg.c'. */
-/*#define C_GETLOADAVG 1*/
+#define C_GETLOADAVG
 
 /* Define to 1 for DGUX with <sys/dg_sys_info.h>. */
 /* #undef DGUX */
@@ -66,8 +66,8 @@
 /* Define if your compiler conforms to the ANSI C standard. */
 #define HAVE_ANSI_COMPILER 1
 
-/* Define to 1 if you have the `bsd_signal' function. */
-/* #undef HAVE_BSD_SIGNAL */
+/* Define to 1 if you have the 'atexit' function. */
+#define HAVE_ATEXIT 1
 
 /* Use case insensitive file names */
 /* #undef HAVE_CASE_INSENSITIVE_FS */
@@ -79,6 +79,22 @@
    */
 /* #undef HAVE_DCGETTEXT */
 
+/* Define to 1 if you have the declaration of `bsd_signal', and to 0 if you
+   don't. */
+#define HAVE_DECL_BSD_SIGNAL 0
+
+/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST 0
+
+/* Define to 1 if you have the declaration of `_sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL__SYS_SIGLIST 0
+
+/* Define to 1 if you have the declaration of `__sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL___SYS_SIGLIST 0
+
 /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
    */
 #define HAVE_DIRENT_H 1
@@ -103,7 +119,12 @@
 #define HAVE_FCNTL_H 1
 
 /* Define to 1 if you have the `fdopen' function. */
-/*#define HAVE_FDOPEN 1*/
+#ifdef __MINGW32__
+#define HAVE_FDOPEN 1
+#endif
+
+/* Define to 1 if you have the `fileno' function. */
+#define HAVE_FILENO 1
 
 /* Define to 1 if you have the `fork' function. */
 /* #undef HAVE_FORK */
@@ -129,14 +150,18 @@
 /* Define if the GNU gettext() function is already present or preinstalled. */
 /* #undef HAVE_GETTEXT */
 
-/* Define if you have a standard gettimeofday function */
-/* #undef HAVE_GETTIMEOFDAY */
+/* Define to 1 if you have a standard gettimeofday function */
+#ifdef __MINGW32__
+#define HAVE_GETTIMEOFDAY 1
+#endif
 
 /* Define if you have the iconv() function. */
 /* #undef HAVE_ICONV */
 
 /* Define to 1 if you have the <inttypes.h> header file. */
-/*#define HAVE_INTTYPES_H 1*/
+#ifdef __MINGW32__
+#define HAVE_INTTYPES_H 1
+#endif
 
 /* Define to 1 if you have the `dgc' library (-ldgc). */
 /* #undef HAVE_LIBDGC */
@@ -150,12 +175,12 @@
 /* Define to 1 if you have the <locale.h> header file. */
 /*#define HAVE_LOCALE_H 1*/
 
+/* Define to 1 if you have the `lstat' function. */
+/* #undef HAVE_LSTAT */
+
 /* Define to 1 if you have the <mach/mach.h> header file. */
 /* #undef HAVE_MACH_MACH_H */
 
-/* Define to 1 if you have the `memmove' function. */
-#define HAVE_MEMMOVE 1
-
 /* Define to 1 if you have the <memory.h> header file. */
 #define HAVE_MEMORY_H 1
 
@@ -177,6 +202,9 @@
 /* Define to 1 if you have the `pstat_getdynamic' function. */
 /* #undef HAVE_PSTAT_GETDYNAMIC */
 
+/* Define to 1 if you have the `readlink' function. */
+/* #undef HAVE_READLINK */
+
 /* Define to 1 if you have the `realpath' function. */
 /* #undef HAVE_REALPATH */
 
@@ -220,48 +248,56 @@
 #define HAVE_STDARG_H 1
 
 /* Define to 1 if you have the <stdint.h> header file. */
-/*#define HAVE_STDINT_H 1*/
+#ifdef __MINGW32__
+#define HAVE_STDINT_H 1
+#endif
 
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
 /* Define to 1 if you have the `strcasecmp' function. */
-/* #undef HAVE_STRCASECMP */
+#ifdef __MINGW32__
+#define HAVE_STRCASECMP 1
+#endif
 
 /* Define to 1 if you have the `strcmpi' function. */
-/* #undef HAVE_STRCMPI */
-
-/* Define to 1 if you have the `stricmp' function. */
-#define HAVE_STRICMP 1
-
-/* Define to 1 if you have the `strncasecmp' function. */
-/* #undef HAVE_STRNCASECMP */
-
-/* Define to 1 if you have the `strncmpi' function. */
-/* #undef HAVE_STRNCMPI */
-
-/* Define to 1 if you have the `strnicmp' function. */
-#define HAVE_STRNICMP 1
-
-/* Define to 1 if you have the `strchr' function. */
-#define HAVE_STRCHR 1
+#define HAVE_STRCMPI 1
 
 /* Define to 1 if you have the `strcoll' function and it is properly defined.
    */
 #define HAVE_STRCOLL 1
 
 /* Define to 1 if you have the `strdup' function. */
-/* #define HAVE_STRDUP 1*/
+#define HAVE_STRDUP 1
 
 /* Define to 1 if you have the `strerror' function. */
 #define HAVE_STRERROR 1
 
+/* Define to 1 if you have the `stricmp' function. */
+#define HAVE_STRICMP 1
+
 /* Define to 1 if you have the <strings.h> header file. */
 /* #define HAVE_STRINGS_H 1 */
 
 /* Define to 1 if you have the <string.h> header file. */
 #define HAVE_STRING_H 1
 
+/* Define to 1 if you have the `strncasecmp' function. */
+#ifdef __MINGW32__
+#define HAVE_STRNCASECMP 1
+#endif
+
+/* Define to 1 if you have the `strncmpi' function. */
+/* #undef HAVE_STRNCMPI */
+
+/* Define to 1 if you have the `strndup' function. */
+/* #undef HAVE_STRNDUP */
+
+/* Define to 1 if you have the `strnicmp' function. */
+#ifdef __MINGW32__
+#define HAVE_STRNICMP 1
+#endif
+
 /* Define to 1 if you have the `strsignal' function. */
 /* #undef HAVE_STRSIGNAL */
 
@@ -277,22 +313,26 @@
 /* #undef HAVE_SYS_NDIR_H */
 
 /* Define to 1 if you have the <sys/param.h> header file. */
-/* #define HAVE_SYS_PARAM_H 1 */
+#ifdef __MINGW32__
+#define HAVE_SYS_PARAM_H 1
+#endif
 
 /* Define to 1 if you have the <sys/resource.h> header file. */
 /* #undef HAVE_SYS_RESOURCE_H */
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
-/* #define HAVE_SYS_STAT_H 1 */
+#define HAVE_SYS_STAT_H 1
 
 /* Define to 1 if you have the <sys/timeb.h> header file. */
-/*#define HAVE_SYS_TIMEB_H 1*/
+#define HAVE_SYS_TIMEB_H
 
 /* Define to 1 if you have the <sys/time.h> header file. */
-/*#define HAVE_SYS_TIME_H 1*/
+#ifdef __MINGW32__
+#define HAVE_SYS_TIME_H 1
+#endif
 
 /* Define to 1 if you have the <sys/types.h> header file. */
-/*#define HAVE_SYS_TYPES_H 1*/
+#define HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <sys/wait.h> header file. */
 /* #undef HAVE_SYS_WAIT_H */
@@ -301,7 +341,9 @@
 /* #undef HAVE_UNION_WAIT */
 
 /* Define to 1 if you have the <unistd.h> header file. */
-/* #define HAVE_UNISTD_H 1*/
+#ifdef __MINGW32__
+#define HAVE_UNISTD_H 1
+#endif
 
 /* Define to 1 if you have the <varargs.h> header file. */
 /* #undef HAVE_VARARGS_H */
@@ -334,6 +376,9 @@
 /* Define this to enable job server support in GNU make. */
 #define MAKE_JOBSERVER 1
 
+/* Define to 1 to enable symbolic link timestamp checking. */
+/* #undef MAKE_SYMLINKS */
+
 /* Define to 1 if your `struct nlist' has an `n_un' member. Obsolete, depend
    on `HAVE_STRUCT_NLIST_N_UN_N_NAME */
 /* #undef NLIST_NAME_UNION */
@@ -347,8 +392,20 @@
 /* Name of this package (needed by automake) */
 #define PACKAGE "%PACKAGE%"
 
-/* Define to 1 if the C compiler supports function prototypes. */
-#define PROTOTYPES 1
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "bug-make@gnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "GNU make"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://www.gnu.org/software/make/"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "%VERSION%"
+
+/* Define to the character that separates directories in PATH. */
+#define PATH_SEPARATOR_CHAR ';'
 
 /* Define as the return type of signal handlers (`int' or `void'). */
 #define RETSIGTYPE void
@@ -385,7 +442,9 @@
 /* #undef SVR4 */
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-/* #define TIME_WITH_SYS_TIME 1 */
+#ifdef __MINGW32__
+#define TIME_WITH_SYS_TIME 1
+#endif
 
 /* Define to 1 for Encore UMAX. */
 /* #undef UMAX */
@@ -421,10 +480,7 @@
 /* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-#define _POSIX_SOURCE 1
-
-/* Define like PROTOTYPES; this can be used by system headers. */
-/*#define __PROTOTYPES 1*/
+/* #undef _POSIX_SOURCE */
 
 /* Define to empty if `const' does not conform to ANSI C. */
 /* #undef const */
@@ -448,41 +504,16 @@
 #define uid_t int
 
 /* Define uintmax_t if not defined in <stdint.h> or <inttypes.h>. */
-#define uintmax_t unsigned long
+#if !HAVE_STDINT_H && !HAVE_INTTYPES_H
+ #define uintmax_t unsigned long
+#endif
 
 /* Define as `fork' if `vfork' does not work. */
 /*#define vfork fork*/
 
-/* Define to `unsigned long' or `unsigned long long'
-   if <inttypes.h> doesn't define.  */
-#define uintmax_t unsigned long
-
-/* Define if you support file names longer than 14 characters.  */
-#define HAVE_LONG_FILE_NAMES 1
-
-/* Define if your struct stat has st_rdev.  */
-#undef HAVE_ST_RDEV
-#define HAVE_ST_RDEV 1
-
-/* Define if you have the strftime function.  */
-#undef HAVE_STRFTIME
-#define HAVE_STRFTIME 1
-
 /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
 /* #undef HAVE_SYS_WAIT_H */
 
-/* Define if your struct tm has tm_zone.  */
-/* #undef HAVE_TM_ZONE */
-
-/* Define if you don't have tm_zone but do have the external array
-   tzname.  */
-#undef HAVE_TZNAME
-#define HAVE_TZNAME 1
-
-/* Define if utime(file, NULL) sets file's timestamp to the present.  */
-#undef HAVE_UTIME_NULL
-#define HAVE_UTIME_NULL 1
-
 /* Define to the installation directory for locales.  */
 #define LOCALEDIR ""
 
