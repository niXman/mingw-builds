--- gcc-4.8.0/include/filenames.h.orig	2013-05-21 00:29:29.852193269 +0400
+++ gcc-4.8.0/include/filenames.h	2013-05-21 00:31:02.498193187 +0400
@@ -86,6 +86,9 @@
 extern int filename_ncmp (const char *s1, const char *s2,
 			  size_t n);
 
+extern void filename_normalize (char *f);
+#define FILENAME_NORMALIZE(f)  filename_normalize(f)
+
 extern hashval_t filename_hash (const void *s);
 
 extern int filename_eq (const void *s1, const void *s2);
--- gcc-4.8.0/libiberty/filename_cmp.c.orig	2013-05-21 00:31:38.417200064 +0400
+++ gcc-4.8.0/libiberty/filename_cmp.c	2013-05-21 00:36:44.331191266 +0400
@@ -142,6 +142,118 @@
 #endif
 }
 
+#ifdef HAVE_MEMMOVE
+#define memmove_left memmove
+#else
+static void *
+memmove_left (void *dest, const void *src, int n)
+{
+  char *d;
+  const char *s;
+  int i;
+  for (d = (char *)dest, s = (const char *)src, i = 0; i < n; i++)
+    *d++ = *s++;
+}
+#endif
+
+/*
+
+@deftypefn Extension void filename_normalize (char *@var{fn})
+
+This function tries to normalize files names inplace.
+
+@end deftypefn
+
+*/
+
+#ifndef HAVE_DOS_BASED_FILE_SYSTEM
+void
+filename_normalize (char *fn)
+#else
+static void
+filename_normalize_unix (char *fn)
+#endif
+{
+  char *p;
+  int rest;
+
+  rest = strlen (fn) + 1;
+  for (p = fn; *p != '\0' ; p++, rest--)
+    {
+      char *next;
+      const char *next2;
+      const char *next3;
+
+      next = p + 1;
+      if (*next == '\0')
+        break;
+      if (!IS_DIR_SEPARATOR( *p))
+          continue;
+      next2 = p + 2;
+      next3 = p + 3;
+      *p = '/';
+      /* don't handle some special cases, i.e. "//C/" on Microsoft Windows */
+      if (IS_DIR_SEPARATOR (*next))
+        {
+          memmove_left (next, next2, rest - 2);
+          p--;
+          continue;
+        }
+      if (*next != '.' || *next2 == '\0' || *next3 == '\0')
+          continue;
+      /* simplify "./" case */
+      if (IS_DIR_SEPARATOR (*next2))
+        {
+          memmove_left (next, next3, rest - 3);
+          rest--;
+          p--;
+          continue;
+        }
+      if (*next2 != '.' || ! IS_DIR_SEPARATOR (*next3))
+        continue;
+      while (--p >= fn)
+        {
+          if (*p == '/')
+            break;
+        }
+      if (p < fn)
+        {
+          if (*fn == '/')
+              memmove_left (p + 2, next3 + 1, rest - 4);
+          else if (*fn != '.')
+              memmove_left (p + 1, next3 + 1, rest - 4);
+          else
+            {
+              p = next - 1;
+              continue;
+            }
+        }
+      else if (*(p + 1) != '.')
+        {
+          memmove_left (p + 1, next3 + 1, rest - 4);
+          p--;
+        }
+      else
+        {
+          p = next - 1;
+          continue;
+        }
+      rest -= 2;
+    }
+}
+
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+void
+filename_normalize (char *fn)
+{
+  if (IS_DIR_SEPARATOR (fn[0]) || ! IS_ABSOLUTE_PATH (fn))
+    /* Absolute path in Unix style or relative path */
+    filename_normalize_unix (fn);
+  else if (fn[1] != '\0')
+    filename_normalize_unix (fn + 2);
+}
+#endif
+
 /*
 
 @deftypefn Extension hashval_t filename_hash (const void *@var{s})
--- gcc-4.8.0/libcpp/directives.c.orig	2013-05-21 00:37:42.314192589 +0400
+++ gcc-4.8.0/libcpp/directives.c	2013-05-21 00:39:41.656192831 +0400
@@ -729,6 +729,7 @@
       return NULL;
     }
 
+  FILENAME_NORMALIZE (fname);
   if (pfile->directive == &dtable[T_PRAGMA])
     {
       /* This pragma allows extra tokens after the file name.  */
--- gcc-4.8.0/libcpp/files.c.orig	2013-05-27 11:41:07 +0400
+++ gcc-4.8.0/libcpp/files.c	2013-05-27 11:11:18 +0400
@@ -387,6 +387,7 @@
       char *copy;
       void **pp;
 
+      FILENAME_NORMALIZE (path);
       /* We try to canonicalize system headers.  */
       if (CPP_OPTION (pfile, canonical_system_headers) && file->dir->sysp)
 	{
